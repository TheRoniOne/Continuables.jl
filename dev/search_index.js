var documenterSearchIndex = {"docs":
[{"location":"library/","page":"Library","title":"Library","text":"CurrentModule = Continuables","category":"page"},{"location":"library/#Public-API","page":"Library","title":"Public API","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"","category":"page"},{"location":"library/#Core","page":"Library","title":"Core","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Continuable\n@cont\n@Ref","category":"page"},{"location":"library/#Continuables.Continuable","page":"Library","title":"Continuables.Continuable","text":"Continuable(func)\n\nAssumes func to have a single argument, the continuation function (usually named cont).\n\nExample\n\nContinuable(function (cont)\n  for i in 1:10\n    cont(i)\n  end\nend)\n\n\n\n\n\n","category":"type"},{"location":"library/#Conversions","page":"Library","title":"Conversions","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"aschannel\nascontinuable\ni2c\n@i2c","category":"page"},{"location":"library/#Functionality","page":"Library","title":"Functionality","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"singleton\nrepeated\niterate\nreduce\nreduce!\nzip\nproduct\nchain\nflatten\ncycle\nforeach\nmap\nall\nany\nsum\nprod\ntake\ntakewhile\ndrop\ndropwhile\npartition\ngroupbyreduce\ngroupby,\nnth","category":"page"},{"location":"library/#Continuables.reduce!","page":"Library","title":"Continuables.reduce!","text":"mutating version of reduce!\n\nif no init is given     op! is assumed to mutate a hidden state (equivalent to mere continuation) else     init is the explicit state and will be passed to op! as first argument (the accumulator)\n\n\n\n\n\n","category":"function"},{"location":"library/#Continuables.flatten","page":"Library","title":"Continuables.flatten","text":"for iterables of continuable use Continuables.chain(...)\n\n\n\n\n\n","category":"function"},{"location":"library/#Continuables.groupbyreduce","page":"Library","title":"Continuables.groupbyreduce","text":"group elements of continuable by by, aggregating immediately with op2/op1\n\nParameters\n\nby: function of element to return the key for the grouping/dict continuable: will get grouped op2: f(accumulator, element) = newaccumulator op1: f(element) = initialaccumulator\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"cont, @cont, Continuable, @Ref, stoppable, stop, singleton, repeated, iterate, aschannel, ascontinuable, i2c, @i2c, reduce, reduce!, zip, product, chain, flatten, cycle, foreach, map, all, any, sum, prod, take, takewhile, drop, dropwhile, partition, groupbyreduce, groupby, nth","category":"page"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"TLDR: Python / C# yield with performance matching plain Julia iterators  (i.e. unbelievably fast)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Continuables are generator-like higher-order functions which take a continuation as an extra argument. The key macro provided by the package is @cont which will give access to the special function cont within its scope and wraps the computation in a special Type Continuables.Continuable. It is best to think of cont in the sense of yield from Python's Generators. It generates values and takes feedback from the outer process as return value.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"If you come from Python, use Continuables wherever you would use generators. If you are Julia-native, Continuables can be used instead of Julia's Channels in many place with drastic performance-improvements (really drastic: in the little benchmark example below it is 20 million times faster!).","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"This package implements all standard functions like e.g. collect, reduce, any and others. As well as functionalities known from Base.Iterators and IterTools.jl like take, dropwhile, groupby, partition, nth and others.","category":"page"},{"location":"manual/#Example-of-a-Continuable","page":"Manual","title":"Example of a Continuable","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Let's define our fist continuable by wrapping a simple range iterator 1:n.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using Continuables\n# new Continuable ---------------------------------------------\ncorange(n::Integer) = @cont begin\n  for i in 1:n\n    cont(i)\n  end\nend","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"That's it. Very straight forward and intuitive.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Many standard functions work seamlessly for Continuables.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using Continuables\ncollect(corange(10)) == collect(1:10)\n\nco2 = map(corange(5)) do x\n  2x\nend\ncollect(co2) == [2,4,6,8,10]\n\nforeach(println, corange(3))  # 1, 2, 3\n\nforeach(chain(corange(2), corange(4))) do x\n  print(\"$x, \")\nend # 1, 2, 1, 2, 3, 4,  \n\nreduce(*, corange(4)) == 24\n\nall(x -> x < 5, corange(3))\nany(x -> x == 2, corange(3))\n\nmap(corange(10)) do x\n  corange(x)\nend |> flatten |> co -> take(co, 5) |> collect == Any[1,1,2,1,2]\n\ncollect(product(corange(2), corange(3))) == Any[\n  (1, 1),\n  (1, 2),\n  (1, 3),\n  (2, 1),\n  (2, 2),\n  (2, 3),\n]\ncollect(partition(corange(11), 4)) == [\n  Any[1,2,3,4],\n  Any[5,6,7,8],\n  Any[9,10,11],\n]\nusing OrderedCollections\ngroupbyreduce(isodd, corange(5), +) == OrderedDict{Any, Any}(\n  true => 9,\n  false => 6,\n)\n\nnth(3, ascontinuable(4:10)) == 6\nnth(4, i2c(4:10)) == 7\nnth(5, @i2c 4:10) == 8\n\n# further defined are `takewhile`, `drop`, `dropwhile`, `repeated` and `iterate`, as well as `groupby`.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Importantly, Continuables do not support Base.iterate, i.e. you cannot directly for-loop over a Continuable. There is just no direct way to implement iterate on top of Continuables. Give it a try. Instead, you have to convert it into an Array first using collect, or to a Channel using aschannel.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The same holds true for zip, however we provide a convenience implementation where you can choose which interpretation you want to have","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"# uses Channels and hence offers lazy execution, however might be slower\nzip(i2c(1:4), i2c(3:6), lazy=true)  # Default\n\n# uses Array, might be faster, but loads everything into memory  \nzip(i2c(1:4), i2c(3:6), lazy=false)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Last but not least, you can call a Continuable directly. It is just a higher order function expecting a cont function to run its computation.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"continuable = corange(3)\nforeach(print, continuable)  # 123\n# is the very same as\ncontinuable(print)  # 123","category":"page"},{"location":"manual/#The-@Ref-macro","page":"Manual","title":"The @Ref macro","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"As you already saw, for continuables we cannot use for-loops. Instead we use higher-order functions like map, foreach, reduce or groupbyreduce to work with Continuables.   Fortunately, julia supports beautiful do syntax for higher-order functions. In fact, do becomes the equivalent of for for continuables.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"However, importantly, a do-block constructs an anonymous function and consequently what happens within the do-block has its own variable namespace! This is essential if you want to define your own Continuables. You cannot easily change an outer variable from within a do-block like you may have done it within a for-loop. The solution is to simply use julia's Ref object to get mutations instead of simple variable assignments. For example instead of var_changing_every_loop = 0, and an update var_changing_every_loop += 1 you use var_changing_every_loop = Ref(yourvalue) and var_changing_every_loop.x += 1.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"(If you would use something mutable instead like an Vector instead of the non-mutable Int here, you of course can directly work in place. I.e. say a = [], then push!(a, i) will do the right thing also in a do-block).","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"For convenience, Continuables comes with a second macro @Ref which checks your code for variable = Ref(value) parts and replaces all plain assignments var = newvalue with var.x = newvalue. This makes for beautiful code. Let's implement reduce with it:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using Continuables\n@Ref function myreduce(continuable, merge, init)\n  accumulator = Ref(init)\n  continuable() do x\n    accumulator = merge(accumulator, x)\n  end\n  accumulator\nend\nmyreduce(i2c(0:5), +, 0) == 15","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Let's check that @Ref indeed only replaced accumulator with accumulator.x. Run @macroexpand on the whole definition, i.e. @macroexpand @Ref function myreduce(...., which returns","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":":(function myreduce(continuable, merge, init)\n      accumulator = Ref(init)\n      continuable() do x\n          accumulator.x = merge(accumulator.x, x)\n      end\n      accumulator.x\n  end)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"When combining @cont with @Ref do @cont @Ref ..., i.e. let @cont be the outer and @Ref be the inner macro.","category":"page"},{"location":"benchmark/#Benchmark","page":"Benchmark","title":"Benchmark","text":"","category":"section"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"We compare Continuables with standard Julia Channel and iterators for performance an a simple implementation of sum.","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"The equivalent Channel function to the above corange function is:","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"# standard Channel -----------------------------------------------------\nfunction chrange(r)\n  Channel{Int}(1) do ch\n    for i ∈ 1:r\n      put!(ch, i)\n    end\n  end\nend","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"The sum benchmark functions are defined as follows","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"using Continuables\n\n# Summing continuable --------------------------------------\n\n# we use a convenient macro which replaces all uses of r where r was defined as r = Ref(value) with r.x, i.e. the pointer to its referenced value.\n# The effect is that the variable assignment becomes a mutation of the Reference's field.\n# This macro leads to very clean code while being intuitively transparent.\n@Ref function sum_continuable(continuable)\n  a = Ref(0)\n  continuable() do i\n    a += i\n  end\n  a\nend\n\nfunction sum_continuable_withoutref(continuable)\n  # interestingly, this works too, however with a lot of magic happening in the background\n  # which is also decreasing performance\n  a = 0\n  continuable() do i\n    a += i\n  end\n  a\nend\n\n# Summing Task ----------------------------------------------\nfunction sum_iterable(it)\n  a = 0\n  for i in it\n    a += i\n  end\n  a\nend","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"You may need to add BenchmarkTools to your julia project by running ] add BenchmarkTools. All below are tested on the same machine, results may vary for your architecture.","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"We start with the base-line, i.e. summing up the pure range iterator:","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"julia> import BenchmarkTools.@benchmark\njulia> @benchmark sum_iterable(1:1000)\nBenchmarkTools.Trial:\n  memory estimate:  0 bytes\n  allocs estimate:  0\n  --------------\n  minimum time:     1.420 ns (0.00% GC)\n  median time:      1.706 ns (0.00% GC)\n  mean time:        1.663 ns (0.00% GC)\n  maximum time:     16.456 ns (0.00% GC)\n  --------------\n  samples:          10000\n  evals/sample:     1000","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"We reach the same performance with our self-written continuable version of range. However, as you can see below, if you do not use References everywhere (like Ref or arrays or dictionaries) then performance decreases.","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"julia> @benchmark sum_continuable(corange(1000))\nBenchmarkTools.Trial:\n  memory estimate:  0 bytes\n  allocs estimate:  0\n  --------------\n  minimum time:     1.420 ns (0.00% GC)\n  median time:      1.708 ns (0.00% GC)\n  mean time:        1.671 ns (0.00% GC)\n  maximum time:     16.778 ns (0.00% GC)\n  --------------\n  samples:          10000\n  evals/sample:     1000\n\njulia> @benchmark sum_continuable_withoutref(corange(1000))\nBenchmarkTools.Trial:\n  memory estimate:  22.81 KiB\n  allocs estimate:  1460\n  --------------\n  minimum time:     22.658 μs (0.00% GC)\n  median time:      24.315 μs (0.00% GC)\n  mean time:        28.105 μs (2.64% GC)\n  maximum time:     1.925 ms (97.74% GC)\n  --------------\n  samples:          10000\n  evals/sample:     1","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"Last but not least the Channel version of range.","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"julia> @benchmark sum_iterable(chrange(1000))\nBenchmarkTools.Trial:\n  memory estimate:  32.95 KiB\n  allocs estimate:  2026\n  --------------\n  minimum time:     28.208 ms (0.00% GC)\n  median time:      34.169 ms (0.00% GC)\n  mean time:        33.836 ms (0.00% GC)\n  maximum time:     38.737 ms (0.00% GC)\n  --------------\n  samples:          148\n  evals/sample:     1","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"Mind that 1μs = 1000ns and 1ms = 1000μs. So on median we have","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"range median x-times of range\n1:1000 1.706ns 1\ncorange(1000) summed with Ref 1.708ns 1\ncorange(1000) summed without Ref 24315ns 1.4e4\nchrange(1000) 34169000ns 2e7","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"Also note that the continuable version with Ref has 0 bytes memory footprint!","category":"page"},{"location":"benchmark/#Related-packages","page":"Benchmark","title":"Related packages","text":"","category":"section"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"There is a package called ResumableFunctions.jl with the same motivation but completely different implementation.","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"using ResumableFunctions\n\n@resumable function rfrange(n::Int)\n  for i in 1:n\n    @yield i\n  end\nend\n\n# apparently the @resumable macro relies of having Base.iterate directly available on the namespace, but Continuables also exports one, so that we have to explicitly declare which we want to use to repair this little @resumable bug\nconst iterate = Base.iterate\n@benchmark sum_iterable(rfrange(1000))","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"The resulting time are as follows on my machine:","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"BenchmarkTools.Trial:\n  memory estimate:  93.84 KiB\n  allocs estimate:  3001\n  --------------\n  minimum time:     453.640 μs (0.00% GC)\n  median time:      475.210 μs (0.00% GC)\n  mean time:        505.774 μs (1.18% GC)\n  maximum time:     4.360 ms (85.91% GC)\n  --------------\n  samples:          9869\n  evals/sample:     1","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"I.e. you see it is an impressive factor of 2.8e5 slower on median compared to the plain range or the Continuables version. It is still a factor 100 faster than the current Channels version, but the Channel one is exceptionally slow (probably because of thread-safety). And in terms of memory allocation, @resumable is even the worst of all for this very simple computation.","category":"page"},{"location":"#Continuables.jl","page":"Home","title":"Continuables.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TLDR: Python / C# yield with performance matching plain Julia iterators  (i.e. unbelievably fast)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Continuables are generator-like higher-order functions which take a continuation as an extra argument. The key macro provided by the package is @cont which will give access to the special function cont within its scope and wraps the computation in a special Type Continuables.Continuable. It is best to think of cont in the sense of yield from Python's Generators. It generates values and takes feedback from the outer process as return value.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you come from Python, use Continuables wherever you would use generators. If you are Julia-native, Continuables can be used instead of Julia's Channels in many place with drastic performance-improvements (really drastic: in the little benchmark example below it is 20 million times faster!).","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package implements all standard functions like e.g. collect, reduce, any and others. As well as functionalities known from Base.Iterators and IterTools.jl like take, dropwhile, groupby, partition, nth and others.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package and some dependencies are not yet centrally registered, but available via a custom registry. All you need to install is the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\npkg\"registry add https://github.com/JuliaRegistries/General\"  # central julia registry\npkg\"registry add https://github.com/schlichtanders/SchlichtandersJuliaRegistry.jl\"  # custom registry\npkg\"add Continuables\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Use it like","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Continuables","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"manual.md\"]","category":"page"},{"location":"#main-index","page":"Home","title":"Library Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"library.md\"]","category":"page"}]
}

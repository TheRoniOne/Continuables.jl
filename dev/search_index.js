var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = Continuables","category":"page"},{"location":"#Continuables","page":"Home","title":"Continuables","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Continuables]","category":"page"},{"location":"#Continuables.Continuable","page":"Home","title":"Continuables.Continuable","text":"Continuable(func)\n\nAssumes func to have a single argument, the continuation function (usually named cont).\n\nExample\n\nContinuable(function (cont)\n  for i in 1:10\n    cont(i)\n  end\nend)\n\n\n\n\n\n","category":"type"},{"location":"#Continuables.azip-Tuple","page":"Home","title":"Continuables.azip","text":"zipping continuables via intermediate array representation\n\nCAUTION: loads everything into memory\n\n\n\n\n\n","category":"method"},{"location":"#Continuables.chzip-Tuple","page":"Home","title":"Continuables.chzip","text":"zipping continuables via Channel\n\n\n\n\n\n","category":"method"},{"location":"#Continuables.cont-Tuple","page":"Home","title":"Continuables.cont","text":"cont is reserved function parameter name\n\n\n\n\n\n","category":"method"},{"location":"#Continuables.flatten-Tuple{Continuable}","page":"Home","title":"Continuables.flatten","text":"for iterables of continuable use Continuables.chain(...)\n\n\n\n\n\n","category":"method"},{"location":"#Continuables.groupbyreduce","page":"Home","title":"Continuables.groupbyreduce","text":"group elements of continuable by by, aggregating immediately with op2/op1\n\nParameters\n\nby: function of element to return the key for the grouping/dict continuable: will get grouped op2: f(accumulator, element) = newaccumulator op1: f(element) = initialaccumulator\n\n\n\n\n\n","category":"function"},{"location":"#Continuables.reduce!-Tuple{Any,Continuable}","page":"Home","title":"Continuables.reduce!","text":"mutating version of reduce!\n\nif no init is given     op! is assumed to mutate a hidden state (equivalent to mere continuation) else     init is the explicit state and will be passed to op! as first argument (the accumulator)\n\n\n\n\n\n","category":"method"},{"location":"#Continuables.stoppable","page":"Home","title":"Continuables.stoppable","text":"contextmanager handling custom breakpoints with stop()\n\nThis is usually only used within creating a new continuable from a previous one Examples\n\n@cont stop_at4(continuable) = stoppable(continuable) do x\n  x == 4 && stop()\n  cont(x)\nend\n\n\n\n\n\n","category":"function"},{"location":"#Continuables.@ifsomething-Tuple{Any}","page":"Home","title":"Continuables.@ifsomething","text":"IterTools.@ifsomething expr\n\nIf expr evaluates to nothing, equivalent to return nothing, otherwise the macro evaluates to the value of expr. Not exported, useful for implementing iterators.\n\njulia> IterTools.@ifsomething iterate(1:2)\n(1, 1)\njulia> let elt, state = IterTools.@ifsomething iterate(1:2, 2); println(\"not reached\"); end\n\n\n\n\n\n","category":"macro"}]
}
